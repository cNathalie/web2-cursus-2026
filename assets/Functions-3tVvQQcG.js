import{j as n}from"./index-u4Ysj0KW.js";function a(r){const e={code:"code",p:"p",strong:"strong",...r.components};return n.jsxs(e.p,{children:['export default "Functies zijn één van de fundamentele bouwblokken in JavaScript.\\r\\n\\r\\nEen functie is een JavaScript procedure; een verzameling van instructies dat een taak uitvoert of een waarde berekent.\\r\\n\\r\\n---\\r\\n\\r\\n## Declaratie\\r\\n\\r\\nOm een functie te gebruiken, moet je deze eerst declareren. Dit doe je door de functie een naam te geven en de instructies die de functie moet uitvoeren tussen accolades te plaatsen.\\r\\n\\r\\n',n.jsx(e.code,{children:"javacript\\r\\nfunction greet() {\\r\\n    console.log('Hello, world!');\\r\\n}\\r\\n"}),"\\r\\n\\r\\nDeze functie heet ",n.jsx(e.code,{children:"greet"})," en zal de string ",n.jsx(e.code,{children:"'Hello, world!'"})," loggen naar de console wanneer deze wordt aangeroepen.\\r\\n\\r\\nWe maken gebruik van het keyword ",n.jsx(e.code,{children:"function"}),".\\r\\n\\r\\nWe kunnen ook een functie maken waarmee we één of meerdere parameters meegeven:\\r\\n\\r\\n",n.jsx(e.code,{children:"javacript\\r\\nfunction greet(name) {\\r\\n    console.log(`Hello, ${name}!`);\\r\\n}\\r\\n\\r\\ngreet('John');\\r\\n"}),"\\r\\n\\r\\nDeze functie heet ",n.jsx(e.code,{children:"greet"})," en zal de string ",n.jsx(e.code,{children:"'Hello, John!'"})," loggen naar de console wanneer deze wordt aangeroepen. De parameter in een string.\\r\\n\\r\\nEen functie heeft vaak een ",n.jsx(e.code,{children:"return"})," waarde:\\r\\n\\r\\n",n.jsx(e.code,{children:"javacript\\r\\nfunction add(a, b) {\\r\\n    return a + b;\\r\\n}\\r\\n\\r\\nconst sum = add(2, 3);\\r\\nconsole.log(sum); // 5\\r\\n"}),"\\r\\n\\r\\nDeze functie heet ",n.jsx(e.code,{children:"add"})," en zal de som van de twee parameters ",n.jsx(e.code,{children:"a"})," en ",n.jsx(e.code,{children:"b"})," teruggeven.\\r\\n\\r\\n---\\r\\n\\r\\n## Functies aanroepen\\r\\n\\r\\nOm een functie aan te roepen, schrijf je de naam van de functie gevolgd door ronde haakjes. Als de functie parameters verwacht, geef je deze mee tussen de haakjes.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nmyFunction();\\r\\n\\r\\nmyFunctionWithParams(\\"hello\\", \\"world\\");\\r\\n'}),"\\r\\n\\r\\n---\\r\\n\\r\\n## Het ",n.jsx(e.code,{children:"return"})," keyword begrijpen\\r\\n\\r\\nHet ",n.jsx(e.code,{children:"return"})," keyword wordt gebruikt om een waarde terug te geven vanuit een functie. Wanneer de functie een waarde teruggeeft, kan je deze waarde opslaan in een variabele.\\r\\n\\r\\n- Een ",n.jsx(e.code,{children:"return"})," statement stopt verdere uitvoering van de function body.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nfunction add(a, b) {\\r\\n  return a + b;\\r\\n  console.log(\\"Deze code wordt niet uitgevoerd\\");\\r\\n}\\r\\n'}),"\\r\\n\\r\\n- ",n.jsx(e.code,{children:"return"})," kan meerdere malen in de function body voorkomen:\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nfunction add(a, b) {\\r\\n  if (a < 0) {\\r\\n    return \\"a is negatief\\";\\r\\n  }\\r\\n  return a + b;\\r\\n}\\r\\n'}),"\\r\\n\\r\\n- Als je een ",n.jsx(e.code,{children:"return"})," statement gebruikt zonder waarde, zal de functie onmiddellijk stoppen en ",n.jsx(e.code,{children:"undefined"})," teruggeven.\\r\\n\\r\\n",n.jsx(e.code,{children:"javascript\\r\\nfunction myFunc() {\\r\\n  return;\\r\\n}\\r\\n\\r\\nconst result = myFunc();\\r\\n\\r\\nconsole.log(result); // undefined\\r\\n"}),"\\r\\n\\r\\n---\\r\\n\\r\\n## Arrow functions\\r\\n\\r\\nArrow functions zijn een nieuwe manier om functies te schrijven in ES6. Ze zijn korter en hebben een andere syntax dan reguliere functies.\\r\\n\\r\\nEen arrow functie wordt gedeclareerd met een arrow operator ",n.jsx(e.code,{children:"=>"}),".\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nconst greet1 = () => {\\r\\n  console.log(\\"Hello, world!\\");\\r\\n};\\r\\n\\r\\ngreet1();\\r\\n'}),"\\r\\n\\r\\nDeze functie heet ",n.jsx(e.code,{children:"greet"})," en zal de string ",n.jsx(e.code,{children:"'Hello, world!'"})," loggen naar de console wanneer deze wordt aangeroepen.\\r\\n\\r\\n- Als de functie maar één statement bevat, kan je de accolades en het ",n.jsx(e.code,{children:"return"})," keyword weglaten.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nconst greet2 = () => console.log(\\"Hello, world!\\");\\r\\ngreet2();\\r\\n'}),"\\r\\n\\r\\n- Als de functie één parameter heeft, kan je de ronde haakjes weglaten.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nconst greet3 = (name) => console.log(`Hello, ${name}!`);\\r\\ngreet3(\\"John\\");\\r\\n'}),"\\r\\n\\r\\n- Als de functie enkel de return waarde van één expressie is, kan je het ",n.jsx(e.code,{children:"return"})," statement weglaten.\\r\\n\\r\\n",n.jsx(e.code,{children:"javascript\\r\\nconst add = (a, b) => a + b;\\r\\nconst sum = add(2, 3);\\r\\nconsole.log(sum); // 5\\r\\n"}),"\\r\\n\\r\\n### Opgelet\\r\\n\\r\\nVia een array functie ken je een waarde toe aan variabele.\\r\\n\\r\\nDe waarde van die variabele is de functie (een functie object).\\r\\n\\r\\nWanneer je de variabele gebruikt zonder ronde haakjes (); dan refereer je naar de waarde van de variabele = het functie object. Maar je roept de functie niet aan!\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nconst greet4 = () => console.log(\\"Hello, world!\\");\\r\\n\\r\\ngreet4; // Doet niets\\r\\n\\r\\ngreet4(); // Voert de functie uit\\r\\n'}),"\\r\\n\\r\\n---\\r\\n\\r\\n## Function body\\r\\n\\r\\nDe body van een functie is de code die tussen de accolades staat. Dit is de code die wordt uitgevoerd wanneer de functie wordt aangeroepen.\\r\\n\\r\\nDe body van een functie kan bestaan uit één of meerdere statements.\\r\\n\\r\\n### Opgelet\\r\\n\\r\\nVeranderingen in de function body aan parameters van een primitief type zijn niet zichtbaar in de scope van de aanroeper:\\r\\n\\r\\n",n.jsx(e.code,{children:"javascript\\r\\nfunction changeValue(value) {\\r\\n  value = 10;\\r\\n}\\r\\n\\r\\nlet x = 5;\\r\\n\\r\\nchangeValue(x);\\r\\n\\r\\nconsole.log(x); // Wat verwacht je hier?\\r\\n\\r\\n// Je moet de nieuwe waarde teruggeven\\r\\nfunction changeValue2(value) {\\r\\n  return 10;\\r\\n}\\r\\n\\r\\nx = changeValue2(x);\\r\\n\\r\\nconsole.log(x);\\r\\n"}),"\\r\\n\\r\\nVeranderingen in de function body aan parameters van een object type zijn wel zichtbaar in de scope van de aanroeper:\\r\\n\\r\\n",n.jsx(e.code,{children:"javascript\\r\\nfunction changeValue(obj) {\\r\\n  obj.value = 10;\\r\\n}\\r\\n\\r\\nlet x = { value: 5 };\\r\\n\\r\\nchangeValue(x);\\r\\n\\r\\nconsole.log(x.value); // Wat verwacht je hier?\\r\\n"}),"\\r\\n\\r\\n---\\r\\n\\r\\n## Rest parameter\\r\\n\\r\\nDe rest parameter syntax laat je een onbepaald aantal argumenten doorgeven aan een functie als een array.\\r\\n\\r\\nDe rest parameter wordt aangeduid met drie puntjes ",n.jsx(e.code,{children:"..."})," gevolgd door de naam van de array waarin de argumenten worden opgeslagen.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nfunction printEveryArg(...args) {\\r\\n  for (let arg of args) {\\r\\n    console.log(arg);\\r\\n  }\\r\\n}\\r\\n\\r\\nprintEveryArg(1, 2, 3, 4, 5);\\r\\nprintEveryArg(\\"a\\", \\"b\\", \\"c\\");\\r\\nprintEveryArg(true, false);\\r\\n'}),"\\r\\n\\r\\nDeze functie heet ",n.jsx(e.code,{children:"printEveryArg"})," en zal elk argument loggen naar de console wanneer deze wordt aangeroepen.\\r\\n\\r\\nDe rest parameter kan enkel de laatste parameter zijn in de functiedeclaratie.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\n// Juist\\r\\nconst printAllWithTitle = (title, ...args) => {\\r\\n    console.log(title)\\r\\n    for (let arg of args) {\\r\\n        console.log(arg);\\r\\n    }\\r\\n}\\r\\n\\r\\nprintAllWithTitle(\\"Fruit\\", \\"appel\\", \\"peer\\", \\"banaan\\");\\r\\nprintAllWithTitle(\\"Nummers\\", 1, 2, 3, 4);\\r\\n\\r\\n// Fout\\r\\nconst printAllWrong = (...args, title) => {\\r\\n    console.log(title)\\r\\n    for (let arg of args) {\\r\\n        console.log(arg);\\r\\n    }\\r\\n} // Uncaught SyntaxError: Rest parameter must be last formal parameter\\r\\n\\r\\n'}),"\\r\\n\\r\\n---\\r\\n\\r\\n## Hoisting\\r\\n\\r\\nFunctie-declaraties worden gehoist. Dit betekent dat je een functie kan aanroepen voordat je deze hebt gedeclareerd.\\r\\nConcreet betekend dit dat je een functie ergens helemaal onderaan in je JS-file kan declareren, en die toch bovenaan in je file kan aanroepen.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\ngreet();\\r\\n\\r\\n// ... andere code\\r\\n\\r\\nfunction greet() {\\r\\n  console.log(\\"Hello, world!\\");\\r\\n}\\r\\n'}),"\\r\\n\\r\\nDeze code zal de string ",n.jsx(e.code,{children:"'Hello, world!'"})," loggen naar de console wanneer deze wordt aangeroepen.\\r\\n\\r\\n---\\r\\n\\r\\n## Doorgeven als parameter\\r\\n\\r\\nFuncties kunnen ook worden doorgegeven als parameters aan andere functies.\\r\\n\\r\\n",n.jsx(e.code,{children:'javascript\\r\\nfunction greet() {\\r\\n  console.log(\\"Hello, world!\\");\\r\\n}\\r\\n\\r\\nfunction callGreet(parameter) {\\r\\n  parameter();\\r\\n}\\r\\n\\r\\ncallGreet(greet);\\r\\n'}),"\\r\\n\\r\\nDeze code zal de string ",n.jsx(e.code,{children:"'Hello, world!'"})," loggen naar de console wanneer deze wordt aangeroepen.\\r\\n\\r\\n---\\r\\n\\r\\n## Scope\\r\\n\\r\\nDe scope van een variabele is de context waarin de variabele bestaat. In JavaScript zijn er twee soorten scope: globale scope en block/lokale scope.\\r\\n\\r\\nVariabelen die gedeclareerd zijn ",n.jsx(e.strong,{children:"buiten een functie"})," hebben een ",n.jsx(e.strong,{children:"globale scope"}),". Deze variabelen zijn beschikbaar in de gehele code.\\r\\n\\r\\nVariabelen die gedeclareerd zijn ",n.jsx(e.strong,{children:"binnen een functie"})," hebben een ",n.jsx(e.strong,{children:"lokale scope"}),". Deze variabelen zijn enkel beschikbaar binnen de functie.\\r\\n\\r\\n",n.jsx(e.strong,{children:"Block scope:"}),"\\r\\n\\r\\nVariabelen die gedeclareerd zijn binnen een block hebben een ",n.jsx(e.strong,{children:"block scope"}),". Een block is een set van accolades ",n.jsx(e.code,{children:"{}"})," en kan bijvoorbeeld een functie body of een if statement zijn.\\r\\n\\r\\nBekijk onderstaande situaties heel goed; goei ze zeker ook eens afzonderlijk in de Console en bekijk de output.\\r\\n\\r\\n",n.jsx(e.code,{children:"javascript\\r\\n// Situatie 1\\r\\nconst myFunc = () => {\\r\\n  let bool = true;\\r\\n  if (true) {\\r\\n    let x = 5;\\r\\n    console.log(bool); // true\\r\\n    console.log(x); // 5\\r\\n  }\\r\\n};\\r\\n\\r\\nmyFunc();\\r\\n\\r\\n// Situatie 2\\r\\nconst myFunc2 = () => {\\r\\n  let bool = true;\\r\\n  if (true) {\\r\\n    let x = 5;\\r\\n    console.log(bool); // true\\r\\n    console.log(x); // 5\\r\\n  }\\r\\n  console.log(bool);\\r\\n};\\r\\n\\r\\nmyFunc2();\\r\\n\\r\\n// Situatie 3\\r\\nconst myFunc3 = () => {\\r\\n  let bool = true;\\r\\n  if (true) {\\r\\n    let x = 5;\\r\\n    console.log(bool); // true\\r\\n    console.log(x); // 5\\r\\n  }\\r\\n  console.log(bool);\\r\\n  console.log(x); // ReferenceError: x is not defined\\r\\n};\\r\\n\\r\\nmyfunc3();\\r\\n\\r\\n// Situatie 4\\r\\nconst myFunc4 = () => {\\r\\n  let bool = true;\\r\\n  if (true) {\\r\\n    let x = 5;\\r\\n  }\\r\\n};\\r\\n\\r\\nconsole.log(bool);\\r\\n"}),'\\r\\n\\r\\nMerk op dat JavaScript je niet zal tegenhouden om variabelen aan te roepen op plaatsen waar deze eigenlijk niet toegankelijk zijn.\\r\\n\\r\\n---\\r\\n\\r\\n## Vervuiling van de Scope\\r\\n\\r\\nVervuiling van de scope treedt op wanneer er variabelen worden gedeclareerd in de globale scope die dezelfde naam hebben als variabelen in de lokale scope.\\r\\n\\r\\nDit kan leiden tot onverwachte resultaten en bugs in je code. Om vervuiling van de scope te voorkomen, gebruik je best unieke, betekenisvolle namen voor je variabelen.\\r\\n"']})}function t(r={}){const{wrapper:e}=r.components||{};return e?n.jsx(e,{...r,children:n.jsx(a,{...r})}):a(r)}export{t as default};
