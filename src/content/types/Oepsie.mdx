import JSDrunk from "/images/js-drunk.png";


JavaScript staat bekend om zijn flexibele (en soms verwarrende) type-conversies. Hier zijn enkele grappige en beruchte voorbeelden waar het mis kan gaan:
<img
  src={JSDrunk}
  alt="JavaScript is drunk"
  style={{ maxWidth: "400px", display: "block", margin: "20px auto" }}
/>

---

**1. String + Number = String**

```js
console.log("11" + 1); // "111"
```

> JavaScript ziet een string en een getal. Omdat de + operator ook voor string-concatenatie gebruikt wordt, zet JavaScript het getal 1 om naar een string en plakt deze achter "11". Het resultaat is dus niet 12, maar "111". Dit kan tot onverwachte resultaten leiden als je rekent met strings!

---

**2. Number - String = Number**

```js
console.log("11" - 1); // 10
```

> Hier gebruikt JavaScript de - operator, die alleen werkt met getallen. JavaScript probeert daarom de string "11" om te zetten naar een getal. Dat lukt, dus 11 - 1 = 10. Dit werkt dus wÃ©l zoals je verwacht, in tegenstelling tot de + operator.

---

**3. true + true = 2**

```js
console.log(true + true); // 2
```

> In JavaScript wordt `true` omgezet naar het getal 1 als je ermee rekent. Dus true + true is eigenlijk 1 + 1 = 2. Dit kan grappig zijn als je niet verwacht dat booleans als getallen worden behandeld.

---

**4. false == 0, maar false !== 0**

```js
console.log(false == 0); // true
console.log(false === 0); // false
```

> Met `==` vergelijkt JavaScript de waarden na type-conversie. `false` wordt omgezet naar 0, dus de vergelijking is waar. Met `===` vergelijkt JavaScript zonder type-conversie, dus een boolean is niet gelijk aan een getal. Dit verschil tussen == en === is een bron van veel bugs!

---

**5. null + 1 = 1**

```js
console.log(null + 1); // 1
```

> Als je null optelt bij een getal, wordt null omgezet naar 0. Dus 0 + 1 = 1. Dit is verwarrend, want je zou kunnen denken dat null "niets" betekent, maar JavaScript behandelt het als 0 in deze context.

---

**6. undefined + 1 = NaN**

```js
console.log(undefined + 1); // NaN
```

> undefined betekent "geen waarde". Als je undefined optelt bij een getal, kan JavaScript er geen getal van maken. Het resultaat is NaN (Not a Number). Dit kan lastig zijn als je niet doorhebt dat een variabele undefined is.

---

**7. "5" - "2" = 3**

```js
console.log("5" - "2"); // 3
```

> Bij de - operator probeert JavaScript beide strings om te zetten naar getallen. Dat lukt, dus 5 - 2 = 3. Dit is anders dan bij de + operator, waar je een string krijgt.

---

**8. [] + {} = "[object Object]"**

```js
console.log([] + {}); // "[object Object]"
console.log(typeof ([] + {})); // "string"
```

> Een lege array wordt omgezet naar een lege string, een leeg object naar "[object Object]". Samen krijg je een string. Dit is verwarrend omdat je misschien een object verwacht, maar je krijgt een string terug!

---

**9. "10" \* "2" = 20**

```js
console.log("10" * "2"); // 20
```

> Bij vermenigvuldigen probeert JavaScript beide strings om te zetten naar getallen. Dat lukt, dus 10 \* 2 = 20. Dit is handig, maar kan tot bugs leiden als je niet doorhebt dat je met strings werkt.

---

**10. [] == ![] // true**

```js
console.log([] == ![]); // true
```

> Dit is een van de meest verwarrende JavaScript-vergelijkingen. De lege array wordt omgezet naar een lege string, en ![] is false. [] == false is true door type-conversie. Dit soort vergelijkingen zijn berucht in JavaScript!

---

Heb je zelf nog een leuke gevonden?
